# 净值计算器 V2 逻辑文档

## 概述

净值计算器 V2 用于计算账户的历史净值曲线，基于逐笔持仓反推和 FIFO（先进先出）虚拟开平仓方法。

---

## 核心公式

```
净值 = 总资产 / 总份额
总资产 = 现货账户价值 + 合约账户价值
```

---

## 整体流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          净值计算 V2 流程                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  步骤1：加载逐笔持仓数据                                                      │
│  ├─ 调用 PositionBackwardCalculator                                         │
│  ├─ 从 API 获取快照和事件数据                                                 │
│  └─ 反推每个事件发生前的持仓状态 (spot_positions, perp_positions)              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  步骤2：成间生区间时                                                          │
│  ├─ 起始：最早事件时间，向下取整到区间边界                                      │
│  ├─ 结束：最后一个 is_snapshot_recorded=True 的事件时间，向下取整到区间边界     │
│  └─ 例如：1h 区间，最后快照在 13:05 → 结束区间为 12:00-13:00                   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  步骤3：提取所有币种                                                          │
│  ├─ 遍历所有持仓记录                                                          │
│  ├─ 提取现货币种 (spot_coins)                                                 │
│  └─ 提取合约币种 (perp_coins)                                                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  步骤4：预加载价格数据                                                        │
│  ├─ 调用 K 线 API 获取所有币种的价格                                           │
│  ├─ 现货：get_open_prices(coin, 'spot', interval, start, end)               │
│  ├─ 合约：get_open_prices(coin, 'perp', interval, start, end)               │
│  └─ 将价格存入 intervals_df 的列中 ({coin}_spot_price, {coin}_perp_price)     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  步骤5：计算现货账户价值 (spot_account_value)                                  │
│                                                                              │
│  对每个区间 T:                                                                │
│  ├─ 1. 找到 T 之前最近的 spot_positions                                       │
│  ├─ 2. 解析持仓 {coin: amount}                                               │
│  ├─ 3. 从预加载的价格列获取价格 (USDC 价格固定 = 1.0)                          │
│  └─ 4. spot_value = Σ(amount × price)                                       │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  步骤6：计算合约账户价值 (perp_account_value) - FIFO 方法                      │
│                                                                              │
│  对每个区间 [T_n, T_n+1]:                                                     │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  1. 获取 T_n 时的持仓，用 T_n 价格重新虚拟开仓，初始化 FIFO 队列          │   │
│  │     队列格式: {coin: [(price1, amount1), (price2, amount2), ...]}       │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  2. 获取区间内的所有合约交易                                             │   │
│  │     按优先级排序：开仓 > 翻转 > 平仓 > 清算/ADL                          │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  3. FIFO 模拟交易，计算 realized_pnl                                     │   │
│  │     ├─ Open Long/Short: 入队                                            │   │
│  │     ├─ Close Long: 出队计算 (平仓价 - 开仓价) × 数量                      │   │
│  │     ├─ Close Short: 出队计算 (开仓价 - 平仓价) × 数量                     │   │
│  │     └─ 其他情况: Short>Long, Long>Short, ADL, 清算, 结算                 │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  4. 用 T_n+1 价格虚拟平仓，计算 virtual_pnl                              │   │
│  │     ├─ 多头: (当前价 - 开仓价) × 数量                                     │   │
│  │     └─ 空头: (开仓价 - 当前价) × |数量|                                   │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  5. 计算合约资产变化 (asset_changes)                                     │   │
│  │     从 perp_asset_change_ex_position 累加（资金费、手续费等）             │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  6. perp_account_value = 上一行 + realized_pnl + virtual_pnl             │   │
│  │                          + asset_changes                                 │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  步骤7：计算净值                                                              │
│                                                                              │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  1. total_assets = spot_account_value + perp_account_value             │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  2. 初始化（第一个 total_assets ≠ 0 的区间）                             │   │
│  │     ├─ total_shares = total_assets                                      │   │
│  │     └─ net_value = 1.0                                                  │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  3. 处理份额变化（充值/提现/转账）                                        │   │
│  │     ├─ share_change 格式: "5.0/current_net_value"                       │   │
│  │     ├─ 份额变化量 = 数值 / 上一行净值                                     │   │
│  │     └─ current_shares = prev_shares + 份额变化量                        │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                              │                                               │
│                              ▼                                               │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │  4. net_value = total_assets / total_shares                            │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                          ┌─────────────────┐
                          │   输出结果       │
                          │  - 净值曲线     │
                          │  - 收益率       │
                          │  - 累计PnL      │
                          └─────────────────┘
```

---

## 各步骤详细说明

### 步骤1：加载逐笔持仓数据

**调用模块**: `PositionBackwardCalculator`

**数据来源**:
- 快照数据：从 API 获取历史持仓快照
- 事件数据：从 API 获取交易、资金费、账本事件

**处理逻辑**:
1. 从最新快照开始
2. 按时间倒序遍历每个事件
3. 撤销事件影响，计算该事件发生前的持仓状态
4. 遇到快照时校验并修正

**输出**: DataFrame，包含每个事件的 `spot_positions` 和 `perp_positions`

---

### 步骤2：生成时间区间

**支持的区间**: `1h`, `2h`, `4h`, `8h`, `12h`, `1d`

**时间范围**:
- **起始时间**: 最早事件的时间戳，向下取整到区间边界
- **结束时间**: 最后一个 `is_snapshot_recorded=True` 的事件时间，向下取整到区间边界

**示例（1h 区间）**:
- 最早事件时间：12.1 号 09:23 → 起始区间 09:00
- 最后快照事件时间：12.4 号 13:05 → 结束区间 13:00
- 生成区间：12.1 09:00, 12.1 10:00, ..., 12.4 12:00, 12.4 13:00

**逻辑**:
```python
# 注意：positions_df 是按时间正序排列的（最早在前，最新在后）
# 起始时间：最早事件（DataFrame 的第一行）
start_timestamp = int(positions_df.iloc[0]['timestamp'])

# 结束时间：找最后一个 is_snapshot_recorded=True（时间上最新的快照）
snapshot_rows = positions_df[positions_df['is_snapshot_recorded'] == True]
if not snapshot_rows.empty:
    end_timestamp = int(snapshot_rows.iloc[-1]['timestamp'])  # 最后一行是最新的
else:
    end_timestamp = int(positions_df.iloc[-1]['timestamp'])  # fallback

# 对齐到区间边界（都向下取整）
start_aligned = (start_timestamp // interval_ms) * interval_ms
end_aligned = ((end_timestamp // interval_ms) + 1) * interval_ms  # +1 确保包含结束区间
timestamps = range(start_aligned, end_aligned, interval_ms)
```

**输出**: `intervals_df`，包含 `timestamp` 和 `time` 列

---

### 步骤3：提取所有币种

**逻辑**: 遍历 `positions_df`，从 `spot_positions` 和 `perp_positions` 中提取所有涉及的币种

**输出**:
- `spot_coins`: 现货币种集合（不含 USDC）
- `perp_coins`: 合约币种集合

---

### 步骤4：预加载价格数据

**调用方法**: `get_open_prices(coin, coin_type, interval, start_time, end_time)`

**存储方式**: 将价格存入 `intervals_df` 的列中
- 现货: `{coin}_spot_price`
- 合约: `{coin}_perp_price`

**优点**: 避免在计算过程中频繁调用 API

---

### 步骤5：计算现货账户价值

**公式**:
```
spot_account_value = Σ(coin_amount × coin_price)
```

**特殊处理**:
- USDC 价格固定为 1.0
- 使用区间时间点之前的最近持仓

---

### 步骤6：计算合约账户价值（FIFO 方法）

这是最复杂的部分，采用**每个区间重新虚拟开仓**的方式避免误差累积。

#### 6.1 初始化 FIFO 队列

对每个区间开始时：
```python
for position in prev_perp_positions:
    coin = position['coin']
    amount = position['amount']
    start_price = get_price_at_interval_start(coin)
    
    # 用区间开始价格虚拟开仓
    position_queues[coin] = [(start_price, amount)]
```

#### 6.2 交易优先级排序

| 优先级 | 交易类型 |
|--------|----------|
| 1 | Open Long, Open Short |
| 2 | Short > Long, Long > Short |
| 3 | Close Long, Close Short |
| 4 | Auto-Deleveraging, Settlement, Liquidated* |

#### 6.3 FIFO 模拟交易

| 交易类型 | 处理方式 | PnL 计算 |
|----------|----------|----------|
| Open Long | 入队 (price, amount) | 0 |
| Open Short | 入队 (price, -amount) | 0 |
| Close Long | 出队 | (平仓价 - 开仓价) × 数量 |
| Close Short | 出队 | (开仓价 - 平仓价) × 数量 |
| Short > Long | 先平空再开多 | 平空部分的 PnL |
| Long > Short | 先平多再开空 | 平多部分的 PnL |
| ADL | 根据 side 判断平仓方向 | 对应的平仓 PnL |
| Settlement | 全部平仓 | (结算价 - 开仓价) × 数量 |

#### 6.4 虚拟平仓计算

区间结束时，用结束价格计算未实现盈亏：
```python
for coin, queue in position_queues.items():
    end_price = get_price_at_interval_end(coin)
    for (open_price, amount) in queue:
        if amount > 0:  # 多头
            virtual_pnl += (end_price - open_price) * amount
        else:  # 空头
            virtual_pnl += (open_price - end_price) * abs(amount)
```

#### 6.5 最终计算

```python
perp_account_value = prev_perp_account_value + realized_pnl + virtual_pnl + asset_changes
```

其中 `asset_changes` 包括：
- 资金费（funding fee）
- 交易手续费（fee）

---

### 步骤7：计算净值

#### 7.1 计算总资产

```python
total_assets = spot_account_value + perp_account_value
```

#### 7.2 初始化份额

找到第一个 `total_assets ≠ 0` 的区间：
```python
total_shares = total_assets  # 初始份额 = 初始资产
net_value = 1.0              # 初始净值 = 1.0
```

#### 7.3 处理份额变化

份额变化来源于：
- 充值（deposit）: 份额增加
- 提现（withdraw）: 份额减少
- 外部转账（spotTransfer, internalTransfer 等）: 根据方向增减

份额变化格式：`"5.0/current_net_value"` 或 `"-5.0/current_net_value"`

计算公式：
```python
share_delta = change_value / prev_net_value
current_shares = prev_shares + share_delta
```

#### 7.4 计算净值

```python
net_value = total_assets / total_shares
```

---

## 关键概念说明

| 概念 | 说明 |
|------|------|
| **现货账户价值** | Σ(现货持仓数量 × 现货价格) |
| **合约账户价值** | 使用 FIFO 虚拟开平仓计算，包含 realized_pnl + virtual_pnl + 资金费等 |
| **总份额** | 账户的份额单位，充提时会变化 |
| **净值** | 单位份额的价值，反映投资收益 |
| **FIFO 虚拟开仓** | 每个区间用开始价格重新初始化队列，避免误差累积 |
| **份额变化** | 充值增加份额，提现减少份额（公式：金额 / 当前净值） |
| **realized_pnl** | 实际平仓产生的盈亏 |
| **virtual_pnl** | 持仓未平仓的浮动盈亏 |

---

## 数据流向图

```
┌─────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  API 数据    │────▶│ EventImpactRecorder │────▶│ positions_df   │
│  - trades   │     │ （事件影响计算）     │     │ （逐笔持仓）    │
│  - funding  │     └──────────────────┘     └────────┬────────┘
│  - ledger   │                                       │
│  - snapshots│     ┌──────────────────┐              │
└─────────────┘     │PositionBackward  │◀─────────────┘
                    │   Calculator     │
                    │ （持仓反推校验）   │
                    └──────────────────┘
                              │
                              ▼
┌─────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  K线 API    │────▶│ NetValueCalculator │────▶│ intervals_df   │
│  - 现货价格  │     │      V2           │     │ - timestamp    │
│  - 合约价格  │     │ （净值计算）        │     │ - spot_value   │
└─────────────┘     └──────────────────┘     │ - perp_value   │
                                             │ - total_assets │
                                             │ - total_shares │
                                             │ - net_value    │
                                             └─────────────────┘
```

---

## 潜在问题和注意事项

### 1. 合约 FIFO 计算复杂

每个区间重新虚拟开仓，逻辑复杂，需要正确处理多种交易类型（开仓、平仓、翻转、ADL、清算、结算等）。

### 2. 价格精度

区间边界的价格使用 K 线开盘价，可能与实际成交价有偏差。

### 3. 份额计算依赖历史

如果某一行净值计算错误，会影响后续所有份额计算。

### 4. 现货/合约账户划分

`accountClassTransfer` 和 `send` 事件需要正确影响两个账户的资产。

### 5. 时间对齐

事件时间戳与区间边界的对齐可能存在边界情况。

---

## 输出字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| `timestamp` | int | 区间时间戳（毫秒） |
| `time` | str | 格式化时间字符串 |
| `spot_account_value` | float | 现货账户价值（USD） |
| `perp_account_value` | float | 合约账户价值（USD） |
| `total_assets` | float | 总资产 = spot + perp |
| `total_shares` | float | 总份额 |
| `net_value` | float | 净值 = 总资产 / 总份额 |
| `realized_pnl` | float | 当前区间的实现盈亏 |
| `virtual_pnl` | float | 当前区间的虚拟盈亏 |
| `cumulative_pnl` | float | 累计实现盈亏 |
| `share_change` | str | 份额变化公式 |

---

## 相关文件

| 文件 | 用途 |
|------|------|
| `caculate_net_value_v2.py` | 净值计算器主程序 |
| `calculate_positions_backward.py` | 持仓反推计算 |
| `event_impact_recorder.py` | 事件影响记录 |
| `data_loader.py` | API 数据加载 |
| `kline_fetcher.py` | K 线价格获取 |

